<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Debug Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .log { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; white-space: pre-wrap; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        button { padding: 10px 20px; margin: 5px; }
    </style>
</head>
<body>
    <h1>WebSocket Debug Test</h1>
    <p>Current URL: <span id="currentUrl"></span></p>
    
    <div>
        <button onclick="testConnection()">Test Connection</button>
        <button onclick="clearLog()">Clear Log</button>
        <button onclick="testTransports()">Test Transports</button>
    </div>
    
    <div id="log"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        document.getElementById('currentUrl').textContent = window.location.href;
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function testConnection() {
            log('ðŸ§ª Starting connection test...', 'info');
            log(`ðŸŒ Current URL: ${window.location.href}`, 'info');
            log(`ðŸ”Œ WebSocket support: ${typeof WebSocket !== 'undefined'}`, 'info');
            
            const socket = io({
                transports: ['polling', 'websocket'],
                timeout: 10000,
                reconnection: false // Don't reconnect for testing
            });
            
            socket.on('connect', () => {
                log(`âœ… Connected successfully!`, 'success');
                log(`ðŸ“¡ Transport: ${socket.io.engine.transport.name}`, 'success');
                log(`ðŸ†” Socket ID: ${socket.id}`, 'success');
                
                // Test sending a message
                socket.emit('test-message', 'Hello from debug test!');
                
                setTimeout(() => {
                    socket.disconnect();
                    log('ðŸ”Œ Disconnected test socket', 'info');
                }, 2000);
            });
            
            socket.on('connect_error', (error) => {
                log(`âŒ Connection failed: ${error.message}`, 'error');
                log(`ðŸ“ Error details: ${JSON.stringify(error)}`, 'error');
            });
            
            socket.on('disconnect', (reason) => {
                log(`ðŸ”Œ Disconnected: ${reason}`, 'info');
            });
            
            socket.io.on('upgrade', () => {
                log(`â¬†ï¸ Transport upgraded to: ${socket.io.engine.transport.name}`, 'success');
            });
            
            setTimeout(() => {
                if (!socket.connected) {
                    log('â° Connection timeout - check server and network', 'error');
                    socket.disconnect();
                }
            }, 10000);
        }
        
        function testTransports() {
            log('ðŸ§ª Testing individual transports...', 'info');
            
            // Test polling only
            log('ðŸ“¡ Testing polling transport...', 'info');
            const pollingSocket = io({
                transports: ['polling'],
                timeout: 5000,
                reconnection: false
            });
            
            pollingSocket.on('connect', () => {
                log('âœ… Polling transport works!', 'success');
                pollingSocket.disconnect();
                
                // Test websocket only after polling succeeds
                setTimeout(() => {
                    log('ðŸ“¡ Testing websocket transport...', 'info');
                    const wsSocket = io({
                        transports: ['websocket'],
                        timeout: 5000,
                        reconnection: false
                    });
                    
                    wsSocket.on('connect', () => {
                        log('âœ… WebSocket transport works!', 'success');
                        wsSocket.disconnect();
                    });
                    
                    wsSocket.on('connect_error', (error) => {
                        log('âŒ WebSocket transport failed (this is expected with Cloudflare)', 'error');
                        log(`ðŸ“ WebSocket error: ${error.message}`, 'error');
                    });
                }, 1000);
            });
            
            pollingSocket.on('connect_error', (error) => {
                log('âŒ Polling transport failed - this is a serious issue', 'error');
                log(`ðŸ“ Polling error: ${error.message}`, 'error');
            });
        }
        
        // Auto-test on page load
        window.addEventListener('load', () => {
            setTimeout(testConnection, 1000);
        });
    </script>
</body>
</html>